Get started with classes and objects in C#

구조적 프로그래밍
- 루프, 조건문 , 서브루틴과 같은 제어 구조를 사용해 명확하고 논리적인 제어 흐름을 강조
- 프로그램을 작고 관리하기 쉬운 함수나 프로시저로 나누는 하향식 접근 방식을 기반으로 함
- 모듈식 접근 방식 -> 각 코드의 독립적 테스트 가능 -> 코드 재사용과 더 쉬운 디버깅 가능
- // 소프트웨어 복잡성 증가 - 기능 간 상호 작용 관리 어려움

객체 지향 프로그래밍 OOP
- 데이터(속성))와 동작(메서드)을 모두 캡슐화하는 객체 개념에 초점을 맞춤 
- 객체를 생성하는 청사진 역할을 하는 '클래스'를 기반으로 함
- 서로 상호작용하는 객체를 중심으로 소프트웨어 설계를 구성 -> 모듈화, 재사용 가능한 코드 구조 ㅇ

용어
- Abstraction (추상화) : 세부 구현을 숨기고 간단한 데이터와 메서드만 노출
- Encapsulation (캡슐화) : 데이터와 그 데이터를 처리하는 메서드를 하나의 단위로 묶어 외부에 노출되는 인터페이스만 제공
- Inheritance (상속) : 한 클래스가 다른 클래스의 속성과 행동을 물려받아 새로운 클래스를 생성함
- Polymorphism (다형성) : 서로 다른 클래스의 객체들을 공통된 슈퍼클래스 객체로 취급할 수 있게 해줌

-------------------

.NET type system

Custom types (사용자 정의 타입)
- struct, class, interface, enum, record 등을 사용
- .NET 라이브러리의 타입을 프로젝트에 추가해 사용 가능

Common type system (CTS)
- 상속 : 모든 타입은 궁극적으로 System.Object에서 상속됨
- 값 타입 vs 참조 타입 : 두 타입은 메모리 할당과 동작 방식이 다름

Value types (값 타입)
- struct : 데이터 복사, 값 직접 저장
- enum : 명명된 정수 상수 집합
- 값 타입은 변경 불가능. 복사 시 별도의 인스턴스로 처리됨

Reference types (참조 타입)
- class, record, array, delegate, interface ...
- 객체의 메모리 주소를 참조
- 변수에 객체를 할당하면 객체 자체가 아니라 그 주소를 복사함

-------------------

Design and Use Classes

C#에서의 클래스와 객체
- 클래스 : 객체의 속성과 메소드를 정의하는 틀. 클래스를 사용해 객체를 만들고 메모리를 할당
- 속성 : 객체의 데이터를 관리
- 메소드 : 객체가 수행할 수 있는 동작을 정의

Namespace
- 클래스를 그룹화하여 관리하기 쉽게 만듦

-------------------

Create class constructors and instantiate objects (클래스 생성자 및 객체 인스턴스화)

클래스 생성자 종류

인스턴스 생성자 :
- 객체가 생성될 때 인스턴스 필드를 초기화하는 데 사용.
- 객체가 생성될 때마다 호출됨
- 생성자는 클래스 이름과 동일, 반환 타입 X
- 클래스는 여러 생성자를 가질 수 ㅇ, 각 생성자는 보통 다른 인자를 받음

정적 생성자 : 
- 클래스의 정적 데이터를 초기화하거나 한 번만 실행해야 하는 작업을 수행. 
- 클래스의 첫 번째 인스턴스가 생성되기 전이나 정적 멤버가 참조되기 전에 자동으로 호출

- 액세스 수정자나 매개변수 X
- 클래스는 정적 생성자를 하나만 가질 수 있음
- 상속, 오버로딩, 직접 호출, 실행 시점 제어 X